/**
 *  http结构： 请求行，请求头，空行，请求体
 *            请求行： http 版本号 ，url ，请求方式
 *            响应行：版本号，状态码，原因
 * 
 * 
 *  http 头都有哪些字段： 
 *          请求头：cache-control是否使用缓存
 *                 Connection：keep-alive与服务器的连接状态
 *                 Host 主机域
 *          返回头：cache-control
 *                 etag唯一标识，缓存用
 *                 last-modified 最后修改时间
 * 
 * 
 *  状态码： 2 开头  成功
 * 
 *          301 永久重定向
 *          302 临时重定向
 *          304 表示可以再缓存中获取数据（协商缓存）
 *          
 *          4 开头 客户端错误
 *          403 跨域
 *          404 请求资源不存在
 * 
 *          5 开头 服务端错误
 * 
 * 
 *  http1.0   http1.1  http2.0有什么区别？
 *        http0.9 只支持 get 请求； 
 * 
 *        http1.0增加了post，head，option，put，delete等  
          HEAD请求：和 get 差不多，但是没有 body，用来检查资源是否有效，不需要消耗更多的贷款去请求这个 url
          OPTION请求：预检请求，判断是否支持跨域（cors）
          PUT：一般用来更改资源
          POST：一般是增加资源
 *          
 *        http1.1增加了长连接 keep-alive，增加了host 域，更节约带宽了，还有缓存中的 max-age（之前是 expire）
 *        强缓存在 http1.0 用的 expire    在 1.1 用的 max-age，因为 expire 记录的是时间点，有可能客户端与服务器的时间不一致，
 *                                                          后来改成一个时长就完美解决了
 *        
 *        http2.0增加了服务器推送，多路复用，头部压缩，以及更接近二进制了
 * 
 *        http3.0增加了QUIC 协议，是基于udp来完成建立连接的
 * 
 * 
 * 
 *  http和 https 的区别，https 怎么实现？
 *      http 是无状态连接，而且是明文传输，不安全，默认 80 端口
 *      https具有机密性、完整性、身份认证和不可否认的特性，默认 443
 * 
 *      首先客户端向服务端发送一个随机值和一个客户端支持的加密算法,并连接到443端口。
        服务端收到以后，会返回另外一个随机值和一个协商好的加密算法，这个算法是刚才发送的那个算法的子集
        随后服务端会再次发送一个 CA 证书，这个 CA 证书实际上就是一个公钥，包含了一些信息（比如颁发机构和有效时间等）
        客户端收到以后会验证这个 CA 证书，比如验证是否过期，是否有效等等，如果验证未通过，会弹窗报错。
        如果验证成功，会生成一个随机值作为预主密钥，客户端使用刚才两个随机值和这个预主密钥组装成会话密钥；再使用刚才服务端发来的公钥进行加密发送给服务端；这个过程是一个非对称加密（公钥加密，私钥解密）
        服务端收到以后使用私钥解密，随后得到那两个随机值和预主密钥，随后再组装成会话密钥。
        客户端在向服务端发起一条信息，这条信息使用会话秘钥加密，用来验证服务端时候能收到加密的信息
        服务端收到以后使用刚才的会话密钥解密，在返回一个会话密钥加密的信息，双方收到以后 SSL 建立完成；这个过程是对称加密（加密和解密是同一个）

 * 
 *  
 */