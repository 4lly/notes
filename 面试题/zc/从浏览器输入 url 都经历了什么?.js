/**
 *  先进行 dns 域名解析，查看本地hosts文件，查看有没有当前域名对应的 ip 地址，若有直接发起请求，没有的话会在本地域名服务器上去找，该查找属于递归
 *  查找，如果本地域名服务器没有找到，会从根域名服务器找，该过程属于迭代查找，查到 ip 或者告诉本地域名服务器下一步去哪里查，直到查到，最后查到对应
 *  的 ip地址后把对应规则保存在本地 hosts 文件中。
 *  
 *  如果想加速之前之后的 http 请求过程，可以使用缓存服务器cdn，过程： 
 *      用户输入 url后，本地DNS 会解析 url 地址，不过会把最终解析权交给CNAME 指向CDN的 DNS 服务器，
 *      CDN的 DNS 服务器会返回给浏览器一个全局负载均衡ip
 *      用户会根据全局负载均衡ip 去请求全局负载均衡服务器
 *      全局负载均衡服务器会根据用户的 ip 地址，url 地址，告诉用户一个区域负载均衡设备，让用户去请求它
 *      区域负载均衡服务器会为用户选择一个离用户较近的最优的缓存服务器，并把 ip 地址给用户
 *      用户向缓存服务器发送请求，如果请求不到想要的资源，会一层一层向上级查找，直到查到
 *  
 *  进行 http 请求，三次握手四次挥手建立断开连接
 * 
 *  服务器处理，可能返回 200 或者304
 *      返回 304说明客户端缓存可用，直接使用客户端缓存即可，该过程属于协商缓存
 *      返回 200的话会同时返回对应的数据
 * 
 *  客户端自上而下执行代码
 *      其中遇到 css加载的时候，css 不会阻塞dom树解析，但是会阻塞dom 树渲染，并且 css 会阻塞下面 js 的执行
 *      然后 js加载，js 记载会影响dom 的解析，之所以会影响，是因为 js可能会增删节点，如果先解析后加载，dom 树还得重新解析，性 能比较差，
 *        如果不想阻止 dom 树解析，可以给 script 标签添加defer 或者 async
 *        defer：不会阻止 dom 解析，等 dom 解析完成后运行，在DOMContentloaed 之前
 *        async: 不会阻止 dom 解析，等该资源下载完成后立即运行
 *      进行 DOM渲染和 render树渲染
 *        获取 html解析为 dom 树，
 *        解析 css形成 cssom（css 树）
 *        将cssom 和 dom合并成渲染树（render树）
 *        进行布局（layout）
 *        进行绘制（painting）
 *        回流重绘
 *           回流必将引起重绘，重绘不一定引起回流
 *              当改变width，height等影响不会的属性会引起回流，或者获取scroll，client，offset时，浏览器为了获取这些值也会回流，
 *              getComputedStyle 也会
 * 
 *              
 *  
 * 
 * 
 * 
 * 
 */